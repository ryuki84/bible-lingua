# VS Code + Gemini + Codex 실전 워크플로우

## 목적
- 1인 개발자가 “기능 단위”로 빠르게 구현하고, 유지보수 가능한 구조로 쌓기
- IDE/AI 도구가 바뀌어도 흔들리지 않는 문서 기반 개발 습관

---

## 도구 역할 분담(재확인)
### ChatGPT Plus
- 설계/의사결정/아키텍처
- UX 문구/플로우 정리
- 코드 리뷰/리팩토링 방향
- Codex 작업 지시서(프롬프트) 작성

### Gemini Code Assist (VS Code)
- 자동완성, 보일러플레이트 생성
- 함수/클래스 뼈대 빠르게 만들기
- “타이핑 보조” 역할

### OpenAI Codex CLI
- 에이전트형 실행(여러 파일 수정/테스트/빌드)
- “기능 단위” 작업을 맡기기
- 결과를 PR/커밋 단위로 정리하기

---

## 기본 개발 루틴(기능 1개 단위)
### Step 0. 문서 먼저(필수)
- 변경/추가가 있으면 `docs/CHANGELOG.md` 또는 `docs/DECISIONS.md`에 먼저 기록
- MVP 범위를 넘는 요구는 `Backlog`로 분리

### Step 1. 브랜치 생성
- docs/*, feat/*, fix/*, chore/* 규칙 준수

### Step 2. 구현(로컬 실행까지)
- VS Code로 빠르게 구현
- Gemini는 “코드 생성/자동완성”으로만 사용(결정은 사람이)

### Step 3. Codex에게 맡길 때(조건)
- 파일 여러 개 수정이 필요할 때
- 테스트/빌드/리팩토링을 반복해야 할 때
- 기능 구현의 “골격”을 빠르게 만들고 싶을 때

### Step 4. 체크리스트
- 로컬 실행 성공(필수)
- 불필요 파일/로그/임시코드 제거
- 문서 업데이트(CHANGELOG + 필요 시 SPEC)

### Step 5. 커밋/푸시
- 커밋 메시지는 목적 중심(작게, 의미 있게)

---

## 프론트엔드(Flutter) 권장 루틴
- `flutter pub get` → `flutter run` 성공까지가 “완료” 기준
- UI는 카드 중심(듀오링고 느낌 최소 구현 규칙 준수)
- 상태관리/아키텍처는 MVP 지나고 확정(초기 과설계 금지)

---

## 백엔드(Spring Boot) 권장 루틴
- `/api/health` 먼저
- `/api/daily` 한 개로 시작
- 데이터는 Verse 중심으로 단순하게

---

## 실패 방지 원칙(중요)
- 기능이 늘어날수록 “문서가 실제 기준”이 되어야 한다
- Codex 결과를 그대로 병합하지 말고, 반드시 로컬 실행 및 최소 리뷰를 한다
- MVP 범위를 넘는 요구는 “지금 안 함”이 정답일 때가 많다
